/* tslint:disable */
/* eslint-disable */
/**
 * TechLogist API
 * API сервер для управления логистикой
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * DTO для передачи роли на фронт
 * @export
 * @interface ModelCheckResponse
 */
export interface ModelCheckResponse {
    /**
     * 
     * @type {ModelRoleEnum}
     * @memberof ModelCheckResponse
     */
    'role'?: ModelRoleEnum;
}


/**
 * DTO для передачи списка типов грузов и связей подразделений и зданий
 * @export
 * @interface ModelDropDownListInfoResponse
 */
export interface ModelDropDownListInfoResponse {
    /**
     * Мапа типов грузов
     * @type {{ [key: string]: string; }}
     * @memberof ModelDropDownListInfoResponse
     */
    'cargo_types'?: { [key: string]: string; };
    /**
     * Мапа связей подразделений и зданий
     * @type {{ [key: string]: string; }}
     * @memberof ModelDropDownListInfoResponse
     */
    'dep_builds'?: { [key: string]: string; };
}
/**
 * DTO для передачи данных авторизации
 * @export
 * @interface ModelLoginRequest
 */
export interface ModelLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof ModelLoginRequest
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelLoginRequest
     */
    'password'?: string;
}
/**
 * Модель заявки
 * @export
 * @interface ModelOrder
 */
export interface ModelOrder {
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    'cargo_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    'cargo_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    'cargo_type_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    'cargo_weight'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    'completion_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    'create_order_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    'depart_loc'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    'driver_rate'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    'goal_loc'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelOrder
     */
    'is_postponed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelOrder
     */
    'is_urgent'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    'order_status_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    'photo_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    'pickup_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    'time'?: string;
}
/**
 * DTO для создания заявки
 * @export
 * @interface ModelOrderCreate
 */
export interface ModelOrderCreate {
    /**
     * 
     * @type {string}
     * @memberof ModelOrderCreate
     */
    'cargo_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderCreate
     */
    'cargo_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderCreate
     */
    'cargo_type_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderCreate
     */
    'cargo_weight'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderCreate
     */
    'depart_loc'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderCreate
     */
    'goal_loc'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelOrderCreate
     */
    'is_urgent'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderCreate
     */
    'photo_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderCreate
     */
    'time'?: string;
}
/**
 * DTO для обновления заявки
 * @export
 * @interface ModelOrderForUpdateResponse
 */
export interface ModelOrderForUpdateResponse {
    /**
     * OrderForUpdate DTO для обновления заявки
     * @type {ModelOrderCreate}
     * @memberof ModelOrderForUpdateResponse
     */
    'order_for_update'?: ModelOrderCreate;
}
/**
 * DTO для передачи информации о заявке
 * @export
 * @interface ModelOrderOut
 */
export interface ModelOrderOut {
    /**
     * 
     * @type {string}
     * @memberof ModelOrderOut
     */
    'cargo_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderOut
     */
    'cargo_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderOut
     */
    'cargo_type_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderOut
     */
    'cargo_weight'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderOut
     */
    'depart_loc_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderOut
     */
    'dispatcher_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderOut
     */
    'driver_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderOut
     */
    'goal_loc_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderOut
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelOrderOut
     */
    'is_urgent'?: boolean;
    /**
     * 
     * @type {ModelOrderStatusEnum}
     * @memberof ModelOrderOut
     */
    'order_status_name'?: ModelOrderStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderOut
     */
    'photo_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderOut
     */
    'time'?: string;
}


/**
 * Статус заказа
 * @export
 * @enum {string}
 */

export const ModelOrderStatusEnum = {
    NEW: 'Новый',
    ACCEPT: 'Принят',
    COMPLETE: 'Выполнен',
    CANCEL: 'Отменен',
    UNKNOWN: 'Неизвестно'
} as const;

export type ModelOrderStatusEnum = typeof ModelOrderStatusEnum[keyof typeof ModelOrderStatusEnum];


/**
 * DTO для обновления заявки
 * @export
 * @interface ModelOrderUpdate
 */
export interface ModelOrderUpdate {
    /**
     * 
     * @type {string}
     * @memberof ModelOrderUpdate
     */
    'cargo_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderUpdate
     */
    'cargo_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderUpdate
     */
    'cargo_type_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderUpdate
     */
    'cargo_weight'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderUpdate
     */
    'depart_loc'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderUpdate
     */
    'goal_loc'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderUpdate
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelOrderUpdate
     */
    'is_urgent'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderUpdate
     */
    'photo_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderUpdate
     */
    'time'?: string;
}
/**
 * Ответ со списком заявок
 * @export
 * @interface ModelOrdersResponse
 */
export interface ModelOrdersResponse {
    /**
     * 
     * @type {number}
     * @memberof ModelOrdersResponse
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ModelOrderOut>}
     * @memberof ModelOrdersResponse
     */
    'orders'?: Array<ModelOrderOut>;
}
/**
 * DTO для передачи данных регистрации
 * @export
 * @interface ModelRegisterRequest
 */
export interface ModelRegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof ModelRegisterRequest
     */
    'fio'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelRegisterRequest
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelRegisterRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelRegisterRequest
     */
    'phone'?: string;
    /**
     * 
     * @type {ModelRoleEnum}
     * @memberof ModelRegisterRequest
     */
    'role'?: ModelRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof ModelRegisterRequest
     */
    'role_password'?: string;
}


/**
 * Роль пользователя в системе
 * @export
 * @enum {string}
 */

export const ModelRoleEnum = {
    DRIVER: 'driver',
    DISP: 'disp',
    ADMIN: 'admin',
    MAIN_ADMIN: 'mainAdmin'
} as const;

export type ModelRoleEnum = typeof ModelRoleEnum[keyof typeof ModelRoleEnum];


/**
 * 
 * @export
 * @interface ModelTLIdentetyModelUser
 */
export interface ModelTLIdentetyModelUser {
    /**
     * 
     * @type {string}
     * @memberof ModelTLIdentetyModelUser
     */
    'fio'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelTLIdentetyModelUser
     */
    'internal_id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelTLIdentetyModelUser
     */
    'is_denied'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelTLIdentetyModelUser
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelTLIdentetyModelUser
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelTLIdentetyModelUser
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelTLIdentetyModelUser
     */
    'public_id'?: string;
}
/**
 * DTO для обновления информации о пользователе
 * @export
 * @interface ModelUserUpdate
 */
export interface ModelUserUpdate {
    /**
     * 
     * @type {string}
     * @memberof ModelUserUpdate
     */
    'fio'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelUserUpdate
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelUserUpdate
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelUserUpdate
     */
    'phone'?: string;
}

/**
 * CheckApi - axios parameter creator
 * @export
 */
export const CheckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Проверка подключения к сервису
         * @summary Проверка подключения к сервису
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckApi - functional programming interface
 * @export
 */
export const CheckApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CheckApiAxiosParamCreator(configuration)
    return {
        /**
         * Проверка подключения к сервису
         * @summary Проверка подключения к сервису
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckApi.checkGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CheckApi - factory interface
 * @export
 */
export const CheckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CheckApiFp(configuration)
    return {
        /**
         * Проверка подключения к сервису
         * @summary Проверка подключения к сервису
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkGet(options?: RawAxiosRequestConfig): AxiosPromise<ModelCheckResponse> {
            return localVarFp.checkGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CheckApi - object-oriented interface
 * @export
 * @class CheckApi
 * @extends {BaseAPI}
 */
export class CheckApi extends BaseAPI {
    /**
     * Проверка подключения к сервису
     * @summary Проверка подключения к сервису
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckApi
     */
    public checkGet(options?: RawAxiosRequestConfig) {
        return CheckApiFp(this.configuration).checkGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IdentityApi - axios parameter creator
 * @export
 */
export const IdentityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Создает нового пользователя в системе
         * @summary Зарегистрировать нового пользователя
         * @param {ModelRegisterRequest} user Данные для регистрации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPublicAuthRegisterPost: async (user: ModelRegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('apiPublicAuthRegisterPost', 'user', user)
            const localVarPath = `/api/public/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о пользователе по его ID (int или UUID)
         * @summary Получить пользователя по ID
         * @param {string} id ID пользователя (число или UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identUsersIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('identUsersIdGet', 'id', id)
            const localVarPath = `/ident/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет информацию о пользователе по его ID (int или UUID)
         * @summary Обновить данные пользователя
         * @param {string} id ID пользователя (число или UUID)
         * @param {ModelUserUpdate} user Данные для обновления
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identUsersIdPatch: async (id: string, user: ModelUserUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('identUsersIdPatch', 'id', id)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('identUsersIdPatch', 'user', user)
            const localVarPath = `/ident/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Входит в систему
         * @summary Входит в систему
         * @param {ModelLoginRequest} user Данные для входа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicAuthLoginPost: async (user: ModelLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('publicAuthLoginPost', 'user', user)
            const localVarPath = `/public/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Выходит из системы
         * @summary Выходит из системы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicAuthLogoutPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityApi - functional programming interface
 * @export
 */
export const IdentityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentityApiAxiosParamCreator(configuration)
    return {
        /**
         * Создает нового пользователя в системе
         * @summary Зарегистрировать нового пользователя
         * @param {ModelRegisterRequest} user Данные для регистрации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPublicAuthRegisterPost(user: ModelRegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPublicAuthRegisterPost(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.apiPublicAuthRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает информацию о пользователе по его ID (int или UUID)
         * @summary Получить пользователя по ID
         * @param {string} id ID пользователя (число или UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identUsersIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelTLIdentetyModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identUsersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.identUsersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновляет информацию о пользователе по его ID (int или UUID)
         * @summary Обновить данные пользователя
         * @param {string} id ID пользователя (число или UUID)
         * @param {ModelUserUpdate} user Данные для обновления
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identUsersIdPatch(id: string, user: ModelUserUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identUsersIdPatch(id, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.identUsersIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Входит в систему
         * @summary Входит в систему
         * @param {ModelLoginRequest} user Данные для входа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicAuthLoginPost(user: ModelLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicAuthLoginPost(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.publicAuthLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Выходит из системы
         * @summary Выходит из системы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicAuthLogoutPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicAuthLogoutPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.publicAuthLogoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IdentityApi - factory interface
 * @export
 */
export const IdentityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentityApiFp(configuration)
    return {
        /**
         * Создает нового пользователя в системе
         * @summary Зарегистрировать нового пользователя
         * @param {ModelRegisterRequest} user Данные для регистрации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPublicAuthRegisterPost(user: ModelRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.apiPublicAuthRegisterPost(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает информацию о пользователе по его ID (int или UUID)
         * @summary Получить пользователя по ID
         * @param {string} id ID пользователя (число или UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identUsersIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ModelTLIdentetyModelUser> {
            return localVarFp.identUsersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновляет информацию о пользователе по его ID (int или UUID)
         * @summary Обновить данные пользователя
         * @param {string} id ID пользователя (число или UUID)
         * @param {ModelUserUpdate} user Данные для обновления
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identUsersIdPatch(id: string, user: ModelUserUpdate, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.identUsersIdPatch(id, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Входит в систему
         * @summary Входит в систему
         * @param {ModelLoginRequest} user Данные для входа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicAuthLoginPost(user: ModelLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.publicAuthLoginPost(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Выходит из системы
         * @summary Выходит из системы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicAuthLogoutPost(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.publicAuthLogoutPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdentityApi - object-oriented interface
 * @export
 * @class IdentityApi
 * @extends {BaseAPI}
 */
export class IdentityApi extends BaseAPI {
    /**
     * Создает нового пользователя в системе
     * @summary Зарегистрировать нового пользователя
     * @param {ModelRegisterRequest} user Данные для регистрации
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public apiPublicAuthRegisterPost(user: ModelRegisterRequest, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).apiPublicAuthRegisterPost(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает информацию о пользователе по его ID (int или UUID)
     * @summary Получить пользователя по ID
     * @param {string} id ID пользователя (число или UUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public identUsersIdGet(id: string, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).identUsersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновляет информацию о пользователе по его ID (int или UUID)
     * @summary Обновить данные пользователя
     * @param {string} id ID пользователя (число или UUID)
     * @param {ModelUserUpdate} user Данные для обновления
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public identUsersIdPatch(id: string, user: ModelUserUpdate, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).identUsersIdPatch(id, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Входит в систему
     * @summary Входит в систему
     * @param {ModelLoginRequest} user Данные для входа
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public publicAuthLoginPost(user: ModelLoginRequest, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).publicAuthLoginPost(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Выходит из системы
     * @summary Выходит из системы
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public publicAuthLogoutPost(options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).publicAuthLogoutPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает список всех актуальных заявок
         * @summary Получить все актуальные заявки
         * @param {boolean} [isPrivate] Приватные заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersActualGet: async (isPrivate?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders/actual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isPrivate !== undefined) {
                localVarQueryParameter['isPrivate'] = isPrivate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создает новую заявку в системе
         * @summary Создать новую заявку
         * @param {ModelOrderCreate} order Данные для создания заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersCreatePost: async (order: ModelOrderCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('ordersCreatePost', 'order', order)
            const localVarPath = `/orders/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(order, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Принимает заявку водителем
         * @summary Принять заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdAcceptPatch: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersIdAcceptPatch', 'id', id)
            const localVarPath = `/orders/{id}/accept`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отменяет заявку
         * @summary Отменить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdCancelPatch: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersIdCancelPatch', 'id', id)
            const localVarPath = `/orders/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Завершает заявку
         * @summary Завершить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdCompletePatch: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersIdCompletePatch', 'id', id)
            const localVarPath = `/orders/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о заявке по её ID
         * @summary Получить заявку по ID
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersIdGet', 'id', id)
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет существующую заявку
         * @summary Обновить заявку
         * @param {number} id ID заявки
         * @param {ModelOrderUpdate} order Данные для обновления заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdPatch: async (id: number, order: ModelOrderUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersIdPatch', 'id', id)
            // verify required parameter 'order' is not null or undefined
            assertParamExists('ordersIdPatch', 'order', order)
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(order, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отклоняет заявку водителем
         * @summary Отклонить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdRejectPatch: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersIdRejectPatch', 'id', id)
            const localVarPath = `/orders/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет фотографию из системы
         * @summary Удалить фотографию
         * @param {string} id UUID фотографии
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPhotoIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersPhotoIdDelete', 'id', id)
            const localVarPath = `/orders/photo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отдает файл фотографии по UUID
         * @summary Получить файл фотографии
         * @param {string} id UUID фотографии
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPhotoIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersPhotoIdGet', 'id', id)
            const localVarPath = `/orders/photo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Загружает фотографию в систему
         * @summary Загрузить фотографию
         * @param {File} photo Фотография
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPhotoUploadPost: async (photo: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'photo' is not null or undefined
            assertParamExists('ordersPhotoUploadPost', 'photo', photo)
            const localVarPath = `/orders/photo/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (photo !== undefined) { 
                localVarFormParams.append('photo', photo as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает заявку с данными для обновления
         * @summary Получить заявку для обновления
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersUpdateIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersUpdateIdGet', 'id', id)
            const localVarPath = `/orders/update/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Возвращает список всех актуальных заявок
         * @summary Получить все актуальные заявки
         * @param {boolean} [isPrivate] Приватные заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersActualGet(isPrivate?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelOrdersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersActualGet(isPrivate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersActualGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Создает новую заявку в системе
         * @summary Создать новую заявку
         * @param {ModelOrderCreate} order Данные для создания заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersCreatePost(order: ModelOrderCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersCreatePost(order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Принимает заявку водителем
         * @summary Принять заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersIdAcceptPatch(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersIdAcceptPatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersIdAcceptPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Отменяет заявку
         * @summary Отменить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersIdCancelPatch(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersIdCancelPatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersIdCancelPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Завершает заявку
         * @summary Завершить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersIdCompletePatch(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersIdCompletePatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersIdCompletePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает информацию о заявке по её ID
         * @summary Получить заявку по ID
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelOrder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновляет существующую заявку
         * @summary Обновить заявку
         * @param {number} id ID заявки
         * @param {ModelOrderUpdate} order Данные для обновления заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersIdPatch(id: number, order: ModelOrderUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersIdPatch(id, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Отклоняет заявку водителем
         * @summary Отклонить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersIdRejectPatch(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersIdRejectPatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersIdRejectPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Удаляет фотографию из системы
         * @summary Удалить фотографию
         * @param {string} id UUID фотографии
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersPhotoIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersPhotoIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersPhotoIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Отдает файл фотографии по UUID
         * @summary Получить файл фотографии
         * @param {string} id UUID фотографии
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersPhotoIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersPhotoIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersPhotoIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Загружает фотографию в систему
         * @summary Загрузить фотографию
         * @param {File} photo Фотография
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersPhotoUploadPost(photo: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersPhotoUploadPost(photo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersPhotoUploadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает заявку с данными для обновления
         * @summary Получить заявку для обновления
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersUpdateIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelOrderForUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersUpdateIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersUpdateIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * Возвращает список всех актуальных заявок
         * @summary Получить все актуальные заявки
         * @param {boolean} [isPrivate] Приватные заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersActualGet(isPrivate?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ModelOrdersResponse> {
            return localVarFp.ordersActualGet(isPrivate, options).then((request) => request(axios, basePath));
        },
        /**
         * Создает новую заявку в системе
         * @summary Создать новую заявку
         * @param {ModelOrderCreate} order Данные для создания заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersCreatePost(order: ModelOrderCreate, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ordersCreatePost(order, options).then((request) => request(axios, basePath));
        },
        /**
         * Принимает заявку водителем
         * @summary Принять заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdAcceptPatch(id: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ordersIdAcceptPatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Отменяет заявку
         * @summary Отменить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdCancelPatch(id: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ordersIdCancelPatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Завершает заявку
         * @summary Завершить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdCompletePatch(id: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ordersIdCompletePatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает информацию о заявке по её ID
         * @summary Получить заявку по ID
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ModelOrder> {
            return localVarFp.ordersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновляет существующую заявку
         * @summary Обновить заявку
         * @param {number} id ID заявки
         * @param {ModelOrderUpdate} order Данные для обновления заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdPatch(id: number, order: ModelOrderUpdate, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ordersIdPatch(id, order, options).then((request) => request(axios, basePath));
        },
        /**
         * Отклоняет заявку водителем
         * @summary Отклонить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdRejectPatch(id: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ordersIdRejectPatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Удаляет фотографию из системы
         * @summary Удалить фотографию
         * @param {string} id UUID фотографии
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPhotoIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ordersPhotoIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Отдает файл фотографии по UUID
         * @summary Получить файл фотографии
         * @param {string} id UUID фотографии
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPhotoIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.ordersPhotoIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Загружает фотографию в систему
         * @summary Загрузить фотографию
         * @param {File} photo Фотография
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPhotoUploadPost(photo: File, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ordersPhotoUploadPost(photo, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает заявку с данными для обновления
         * @summary Получить заявку для обновления
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersUpdateIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ModelOrderForUpdateResponse> {
            return localVarFp.ordersUpdateIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * Возвращает список всех актуальных заявок
     * @summary Получить все актуальные заявки
     * @param {boolean} [isPrivate] Приватные заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersActualGet(isPrivate?: boolean, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersActualGet(isPrivate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создает новую заявку в системе
     * @summary Создать новую заявку
     * @param {ModelOrderCreate} order Данные для создания заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersCreatePost(order: ModelOrderCreate, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersCreatePost(order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Принимает заявку водителем
     * @summary Принять заявку
     * @param {number} id ID заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersIdAcceptPatch(id: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersIdAcceptPatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Отменяет заявку
     * @summary Отменить заявку
     * @param {number} id ID заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersIdCancelPatch(id: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersIdCancelPatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Завершает заявку
     * @summary Завершить заявку
     * @param {number} id ID заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersIdCompletePatch(id: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersIdCompletePatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает информацию о заявке по её ID
     * @summary Получить заявку по ID
     * @param {number} id ID заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersIdGet(id: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновляет существующую заявку
     * @summary Обновить заявку
     * @param {number} id ID заявки
     * @param {ModelOrderUpdate} order Данные для обновления заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersIdPatch(id: number, order: ModelOrderUpdate, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersIdPatch(id, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Отклоняет заявку водителем
     * @summary Отклонить заявку
     * @param {number} id ID заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersIdRejectPatch(id: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersIdRejectPatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Удаляет фотографию из системы
     * @summary Удалить фотографию
     * @param {string} id UUID фотографии
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersPhotoIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersPhotoIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Отдает файл фотографии по UUID
     * @summary Получить файл фотографии
     * @param {string} id UUID фотографии
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersPhotoIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersPhotoIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Загружает фотографию в систему
     * @summary Загрузить фотографию
     * @param {File} photo Фотография
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersPhotoUploadPost(photo: File, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersPhotoUploadPost(photo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает заявку с данными для обновления
     * @summary Получить заявку для обновления
     * @param {number} id ID заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersUpdateIdGet(id: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersUpdateIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReferencyApi - axios parameter creator
 * @export
 */
export const ReferencyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает список типов грузов и связей подразделений и зданий
         * @summary Возвращает список типов грузов и связей подразделений и зданий
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refDropdownListInfoGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ref/dropdown-list-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferencyApi - functional programming interface
 * @export
 */
export const ReferencyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferencyApiAxiosParamCreator(configuration)
    return {
        /**
         * Возвращает список типов грузов и связей подразделений и зданий
         * @summary Возвращает список типов грузов и связей подразделений и зданий
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refDropdownListInfoGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelDropDownListInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refDropdownListInfoGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferencyApi.refDropdownListInfoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReferencyApi - factory interface
 * @export
 */
export const ReferencyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferencyApiFp(configuration)
    return {
        /**
         * Возвращает список типов грузов и связей подразделений и зданий
         * @summary Возвращает список типов грузов и связей подразделений и зданий
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refDropdownListInfoGet(options?: RawAxiosRequestConfig): AxiosPromise<ModelDropDownListInfoResponse> {
            return localVarFp.refDropdownListInfoGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferencyApi - object-oriented interface
 * @export
 * @class ReferencyApi
 * @extends {BaseAPI}
 */
export class ReferencyApi extends BaseAPI {
    /**
     * Возвращает список типов грузов и связей подразделений и зданий
     * @summary Возвращает список типов грузов и связей подразделений и зданий
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferencyApi
     */
    public refDropdownListInfoGet(options?: RawAxiosRequestConfig) {
        return ReferencyApiFp(this.configuration).refDropdownListInfoGet(options).then((request) => request(this.axios, this.basePath));
    }
}



