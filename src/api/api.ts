/* tslint:disable */
/* eslint-disable */
/**
 * TechLogist API
 * API сервер для управления логистикой
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * DTO для передачи роли на фронт
 * @export
 * @interface ModelCheckResponse
 */
export interface ModelCheckResponse {
    /**
     * 
     * @type {ModelRoleEnum}
     * @memberof ModelCheckResponse
     */
    'role'?: ModelRoleEnum;
}


/**
 * DTO для передачи данных авторизации
 * @export
 * @interface ModelLoginRequest
 */
export interface ModelLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof ModelLoginRequest
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelLoginRequest
     */
    'password'?: string;
}
/**
 * Модель заявки
 * @export
 * @interface ModelOrder
 */
export interface ModelOrder {
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    'cargo_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    'cargo_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    'cargo_type_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    'cargo_weight'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    'completion_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    'create_order_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    'depart_loc'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    'driver_rate'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    'goal_loc'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelOrder
     */
    'is_postponed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelOrder
     */
    'is_urgent'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    'order_status_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    'photo_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    'pickup_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    'time'?: string;
}
/**
 * DTO для создания заявки
 * @export
 * @interface ModelOrderCreate
 */
export interface ModelOrderCreate {
    /**
     * 
     * @type {string}
     * @memberof ModelOrderCreate
     */
    'cargo_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderCreate
     */
    'cargo_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderCreate
     */
    'cargo_type_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderCreate
     */
    'cargo_weight'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderCreate
     */
    'depart_loc'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderCreate
     */
    'goal_loc'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderCreate
     */
    'photo_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderCreate
     */
    'time'?: string;
}
/**
 * DTO для передачи информации о заявке
 * @export
 * @interface ModelOrderOut
 */
export interface ModelOrderOut {
    /**
     * 
     * @type {string}
     * @memberof ModelOrderOut
     */
    'cargo_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderOut
     */
    'cargo_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderOut
     */
    'cargo_type_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderOut
     */
    'cargo_weight'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderOut
     */
    'depart_loc_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderOut
     */
    'dispatcher_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderOut
     */
    'driver_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderOut
     */
    'goal_loc_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderOut
     */
    'id'?: number;
    /**
     * 
     * @type {ModelOrderStatusEnum}
     * @memberof ModelOrderOut
     */
    'order_status_name'?: ModelOrderStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderOut
     */
    'photo_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderOut
     */
    'time'?: string;
}


/**
 * Статус заказа
 * @export
 * @enum {string}
 */

export const ModelOrderStatusEnum = {
    NEW: 'Новый',
    ACCEPT: 'Принят',
    COMPLETE: 'Выполнен',
    CANCEL: 'Отменен',
    UNKNOWN: 'Неизвестно'
} as const;

export type ModelOrderStatusEnum = typeof ModelOrderStatusEnum[keyof typeof ModelOrderStatusEnum];


/**
 * Ответ со списком заявок
 * @export
 * @interface ModelOrdersResponse
 */
export interface ModelOrdersResponse {
    /**
     * 
     * @type {number}
     * @memberof ModelOrdersResponse
     */
    'count'?: number;
    /**
     * 
     * @type {Array<ModelOrderOut>}
     * @memberof ModelOrdersResponse
     */
    'orders'?: Array<ModelOrderOut>;
}
/**
 * DTO для передачи данных регистрации
 * @export
 * @interface ModelRegisterRequest
 */
export interface ModelRegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof ModelRegisterRequest
     */
    'fio'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelRegisterRequest
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelRegisterRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelRegisterRequest
     */
    'phone'?: string;
    /**
     * 
     * @type {ModelRoleEnum}
     * @memberof ModelRegisterRequest
     */
    'role'?: ModelRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof ModelRegisterRequest
     */
    'role_password'?: string;
}


/**
 * Роль пользователя в системе
 * @export
 * @enum {string}
 */

export const ModelRoleEnum = {
    DRIVER: 'driver',
    DISP: 'disp',
    ADMIN: 'admin',
    MAIN_ADMIN: 'mainAdmin'
} as const;

export type ModelRoleEnum = typeof ModelRoleEnum[keyof typeof ModelRoleEnum];


/**
 * 
 * @export
 * @interface ModelTLIdentetyModelUser
 */
export interface ModelTLIdentetyModelUser {
    /**
     * 
     * @type {string}
     * @memberof ModelTLIdentetyModelUser
     */
    'fio'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelTLIdentetyModelUser
     */
    'internal_id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelTLIdentetyModelUser
     */
    'is_denied'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelTLIdentetyModelUser
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelTLIdentetyModelUser
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelTLIdentetyModelUser
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelTLIdentetyModelUser
     */
    'public_id'?: string;
}
/**
 * DTO для обновления информации о пользователе
 * @export
 * @interface ModelUserUpdate
 */
export interface ModelUserUpdate {
    /**
     * 
     * @type {string}
     * @memberof ModelUserUpdate
     */
    'fio'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelUserUpdate
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelUserUpdate
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelUserUpdate
     */
    'phone'?: string;
}

/**
 * CheckApi - axios parameter creator
 * @export
 */
export const CheckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Проверка подключения к сервису
         * @summary Проверка подключения к сервису
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCheckGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckApi - functional programming interface
 * @export
 */
export const CheckApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CheckApiAxiosParamCreator(configuration)
    return {
        /**
         * Проверка подключения к сервису
         * @summary Проверка подключения к сервису
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCheckGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCheckGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckApi.apiCheckGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CheckApi - factory interface
 * @export
 */
export const CheckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CheckApiFp(configuration)
    return {
        /**
         * Проверка подключения к сервису
         * @summary Проверка подключения к сервису
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCheckGet(options?: RawAxiosRequestConfig): AxiosPromise<ModelCheckResponse> {
            return localVarFp.apiCheckGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CheckApi - object-oriented interface
 * @export
 * @class CheckApi
 * @extends {BaseAPI}
 */
export class CheckApi extends BaseAPI {
    /**
     * Проверка подключения к сервису
     * @summary Проверка подключения к сервису
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckApi
     */
    public apiCheckGet(options?: RawAxiosRequestConfig) {
        return CheckApiFp(this.configuration).apiCheckGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IdentityApi - axios parameter creator
 * @export
 */
export const IdentityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает информацию о пользователе по его ID (int или UUID)
         * @summary Получить пользователя по ID
         * @param {string} id ID пользователя (число или UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIdentUsersIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiIdentUsersIdGet', 'id', id)
            const localVarPath = `/api/ident/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет информацию о пользователе по его ID (int или UUID)
         * @summary Обновить данные пользователя
         * @param {string} id ID пользователя (число или UUID)
         * @param {ModelUserUpdate} user Данные для обновления
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIdentUsersIdPatch: async (id: string, user: ModelUserUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiIdentUsersIdPatch', 'id', id)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('apiIdentUsersIdPatch', 'user', user)
            const localVarPath = `/api/ident/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Входит в систему
         * @summary Входит в систему
         * @param {ModelLoginRequest} user Данные для входа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPublicAuthLoginPost: async (user: ModelLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('apiPublicAuthLoginPost', 'user', user)
            const localVarPath = `/api/public/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создает нового пользователя в системе
         * @summary Зарегистрировать нового пользователя
         * @param {ModelRegisterRequest} user Данные для регистрации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPublicAuthRegisterPost: async (user: ModelRegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('apiPublicAuthRegisterPost', 'user', user)
            const localVarPath = `/api/public/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityApi - functional programming interface
 * @export
 */
export const IdentityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentityApiAxiosParamCreator(configuration)
    return {
        /**
         * Возвращает информацию о пользователе по его ID (int или UUID)
         * @summary Получить пользователя по ID
         * @param {string} id ID пользователя (число или UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIdentUsersIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelTLIdentetyModelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIdentUsersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.apiIdentUsersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновляет информацию о пользователе по его ID (int или UUID)
         * @summary Обновить данные пользователя
         * @param {string} id ID пользователя (число или UUID)
         * @param {ModelUserUpdate} user Данные для обновления
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIdentUsersIdPatch(id: string, user: ModelUserUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIdentUsersIdPatch(id, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.apiIdentUsersIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Входит в систему
         * @summary Входит в систему
         * @param {ModelLoginRequest} user Данные для входа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPublicAuthLoginPost(user: ModelLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPublicAuthLoginPost(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.apiPublicAuthLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Создает нового пользователя в системе
         * @summary Зарегистрировать нового пользователя
         * @param {ModelRegisterRequest} user Данные для регистрации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPublicAuthRegisterPost(user: ModelRegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPublicAuthRegisterPost(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.apiPublicAuthRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IdentityApi - factory interface
 * @export
 */
export const IdentityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentityApiFp(configuration)
    return {
        /**
         * Возвращает информацию о пользователе по его ID (int или UUID)
         * @summary Получить пользователя по ID
         * @param {string} id ID пользователя (число или UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIdentUsersIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ModelTLIdentetyModelUser> {
            return localVarFp.apiIdentUsersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновляет информацию о пользователе по его ID (int или UUID)
         * @summary Обновить данные пользователя
         * @param {string} id ID пользователя (число или UUID)
         * @param {ModelUserUpdate} user Данные для обновления
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIdentUsersIdPatch(id: string, user: ModelUserUpdate, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.apiIdentUsersIdPatch(id, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Входит в систему
         * @summary Входит в систему
         * @param {ModelLoginRequest} user Данные для входа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPublicAuthLoginPost(user: ModelLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.apiPublicAuthLoginPost(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Создает нового пользователя в системе
         * @summary Зарегистрировать нового пользователя
         * @param {ModelRegisterRequest} user Данные для регистрации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPublicAuthRegisterPost(user: ModelRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.apiPublicAuthRegisterPost(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdentityApi - object-oriented interface
 * @export
 * @class IdentityApi
 * @extends {BaseAPI}
 */
export class IdentityApi extends BaseAPI {
    /**
     * Возвращает информацию о пользователе по его ID (int или UUID)
     * @summary Получить пользователя по ID
     * @param {string} id ID пользователя (число или UUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public apiIdentUsersIdGet(id: string, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).apiIdentUsersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновляет информацию о пользователе по его ID (int или UUID)
     * @summary Обновить данные пользователя
     * @param {string} id ID пользователя (число или UUID)
     * @param {ModelUserUpdate} user Данные для обновления
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public apiIdentUsersIdPatch(id: string, user: ModelUserUpdate, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).apiIdentUsersIdPatch(id, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Входит в систему
     * @summary Входит в систему
     * @param {ModelLoginRequest} user Данные для входа
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public apiPublicAuthLoginPost(user: ModelLoginRequest, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).apiPublicAuthLoginPost(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создает нового пользователя в системе
     * @summary Зарегистрировать нового пользователя
     * @param {ModelRegisterRequest} user Данные для регистрации
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public apiPublicAuthRegisterPost(user: ModelRegisterRequest, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).apiPublicAuthRegisterPost(user, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает список всех актуальных заявок
         * @summary Получить все актуальные заявки
         * @param {boolean} [isPrivate] Приватные заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersActualGet: async (isPrivate?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/orders/actual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isPrivate !== undefined) {
                localVarQueryParameter['isPrivate'] = isPrivate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Принимает заявку водителем
         * @summary Принять заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersIdAcceptPatch: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrdersIdAcceptPatch', 'id', id)
            const localVarPath = `/api/orders/{id}/accept`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отменяет заявку
         * @summary Отменить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersIdCancelPatch: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrdersIdCancelPatch', 'id', id)
            const localVarPath = `/api/orders/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Завершает заявку
         * @summary Завершить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersIdCompletePatch: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrdersIdCompletePatch', 'id', id)
            const localVarPath = `/api/orders/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о заявке по её ID
         * @summary Получить заявку по ID
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrdersIdGet', 'id', id)
            const localVarPath = `/api/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отклоняет заявку водителем
         * @summary Отклонить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersIdRejectPatch: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrdersIdRejectPatch', 'id', id)
            const localVarPath = `/api/orders/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создает новую заявку в системе
         * @summary Создать новую заявку
         * @param {ModelOrderCreate} order Данные для создания заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersPost: async (order: ModelOrderCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('apiOrdersPost', 'order', order)
            const localVarPath = `/api/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(order, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Возвращает список всех актуальных заявок
         * @summary Получить все актуальные заявки
         * @param {boolean} [isPrivate] Приватные заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrdersActualGet(isPrivate?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelOrdersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrdersActualGet(isPrivate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.apiOrdersActualGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Принимает заявку водителем
         * @summary Принять заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrdersIdAcceptPatch(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrdersIdAcceptPatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.apiOrdersIdAcceptPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Отменяет заявку
         * @summary Отменить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrdersIdCancelPatch(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrdersIdCancelPatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.apiOrdersIdCancelPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Завершает заявку
         * @summary Завершить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrdersIdCompletePatch(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrdersIdCompletePatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.apiOrdersIdCompletePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает информацию о заявке по её ID
         * @summary Получить заявку по ID
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrdersIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelOrder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrdersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.apiOrdersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Отклоняет заявку водителем
         * @summary Отклонить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrdersIdRejectPatch(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrdersIdRejectPatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.apiOrdersIdRejectPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Создает новую заявку в системе
         * @summary Создать новую заявку
         * @param {ModelOrderCreate} order Данные для создания заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrdersPost(order: ModelOrderCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrdersPost(order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.apiOrdersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * Возвращает список всех актуальных заявок
         * @summary Получить все актуальные заявки
         * @param {boolean} [isPrivate] Приватные заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersActualGet(isPrivate?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ModelOrdersResponse> {
            return localVarFp.apiOrdersActualGet(isPrivate, options).then((request) => request(axios, basePath));
        },
        /**
         * Принимает заявку водителем
         * @summary Принять заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersIdAcceptPatch(id: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.apiOrdersIdAcceptPatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Отменяет заявку
         * @summary Отменить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersIdCancelPatch(id: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.apiOrdersIdCancelPatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Завершает заявку
         * @summary Завершить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersIdCompletePatch(id: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.apiOrdersIdCompletePatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает информацию о заявке по её ID
         * @summary Получить заявку по ID
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ModelOrder> {
            return localVarFp.apiOrdersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Отклоняет заявку водителем
         * @summary Отклонить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersIdRejectPatch(id: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.apiOrdersIdRejectPatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Создает новую заявку в системе
         * @summary Создать новую заявку
         * @param {ModelOrderCreate} order Данные для создания заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersPost(order: ModelOrderCreate, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.apiOrdersPost(order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * Возвращает список всех актуальных заявок
     * @summary Получить все актуальные заявки
     * @param {boolean} [isPrivate] Приватные заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public apiOrdersActualGet(isPrivate?: boolean, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).apiOrdersActualGet(isPrivate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Принимает заявку водителем
     * @summary Принять заявку
     * @param {number} id ID заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public apiOrdersIdAcceptPatch(id: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).apiOrdersIdAcceptPatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Отменяет заявку
     * @summary Отменить заявку
     * @param {number} id ID заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public apiOrdersIdCancelPatch(id: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).apiOrdersIdCancelPatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Завершает заявку
     * @summary Завершить заявку
     * @param {number} id ID заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public apiOrdersIdCompletePatch(id: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).apiOrdersIdCompletePatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает информацию о заявке по её ID
     * @summary Получить заявку по ID
     * @param {number} id ID заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public apiOrdersIdGet(id: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).apiOrdersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Отклоняет заявку водителем
     * @summary Отклонить заявку
     * @param {number} id ID заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public apiOrdersIdRejectPatch(id: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).apiOrdersIdRejectPatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создает новую заявку в системе
     * @summary Создать новую заявку
     * @param {ModelOrderCreate} order Данные для создания заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public apiOrdersPost(order: ModelOrderCreate, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).apiOrdersPost(order, options).then((request) => request(this.axios, this.basePath));
    }
}



