/* tslint:disable */
/* eslint-disable */
/**
 * TechLogist API
 * API сервер для управления логистикой
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * DTO для передачи данных авторизации
 * @export
 * @interface DtoLoginRequest
 */
export interface DtoLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoLoginRequest
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoLoginRequest
     */
    'password'?: string;
}
/**
 * Модель заявки
 * @export
 * @interface DtoOrder
 */
export interface DtoOrder {
    /**
     * 
     * @type {string}
     * @memberof DtoOrder
     */
    'cargo_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoOrder
     */
    'cargo_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoOrder
     */
    'cargo_type_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoOrder
     */
    'cargo_type_snapshot'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoOrder
     */
    'cargo_weight'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoOrder
     */
    'completion_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoOrder
     */
    'create_order_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoOrder
     */
    'depart_loc'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoOrder
     */
    'dispatcher_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoOrder
     */
    'driver_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoOrder
     */
    'driver_rate'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoOrder
     */
    'goal_loc'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoOrder
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DtoOrder
     */
    'is_postponed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DtoOrder
     */
    'is_urgent'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DtoOrder
     */
    'order_status_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DtoOrder
     */
    'photo_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoOrder
     */
    'pickup_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoOrder
     */
    'time'?: string;
}
/**
 * DTO для создания заявки
 * @export
 * @interface DtoOrderCreate
 */
export interface DtoOrderCreate {
    /**
     * 
     * @type {string}
     * @memberof DtoOrderCreate
     */
    'cargo_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoOrderCreate
     */
    'cargo_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoOrderCreate
     */
    'cargo_type_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoOrderCreate
     */
    'cargo_weight'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoOrderCreate
     */
    'depart_loc'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoOrderCreate
     */
    'goal_loc'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DtoOrderCreate
     */
    'is_urgent'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DtoOrderCreate
     */
    'photo_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoOrderCreate
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface DtoOrderForUpdateResponse
 */
export interface DtoOrderForUpdateResponse {
    /**
     * 
     * @type {DtoOrderCreate}
     * @memberof DtoOrderForUpdateResponse
     */
    'order_for_update'?: DtoOrderCreate;
}
/**
 * DTO для обновления заявки
 * @export
 * @interface DtoOrderUpdate
 */
export interface DtoOrderUpdate {
    /**
     * 
     * @type {string}
     * @memberof DtoOrderUpdate
     */
    'cargo_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoOrderUpdate
     */
    'cargo_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof DtoOrderUpdate
     */
    'cargo_type_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoOrderUpdate
     */
    'cargo_weight'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoOrderUpdate
     */
    'depart_loc'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoOrderUpdate
     */
    'goal_loc'?: number;
    /**
     * 
     * @type {number}
     * @memberof DtoOrderUpdate
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof DtoOrderUpdate
     */
    'is_urgent'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DtoOrderUpdate
     */
    'photo_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoOrderUpdate
     */
    'time'?: string;
}
/**
 * DTO для передачи данных регистрации
 * @export
 * @interface DtoRegisterRequest
 */
export interface DtoRegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof DtoRegisterRequest
     */
    'fio'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoRegisterRequest
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoRegisterRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoRegisterRequest
     */
    'phone'?: string;
    /**
     * 
     * @type {DtoRoleStatic}
     * @memberof DtoRegisterRequest
     */
    'role'?: DtoRoleStatic;
    /**
     * 
     * @type {string}
     * @memberof DtoRegisterRequest
     */
    'role_password'?: string;
}


/**
 * Роли пользователей в системе
 * @export
 * @enum {string}
 */

export const DtoRoleStatic = {
    DRIVER: 'driver',
    DISP: 'disp',
    ADMIN: 'admin',
    MAIN_ADMIN: 'mainAdmin'
} as const;

export type DtoRoleStatic = typeof DtoRoleStatic[keyof typeof DtoRoleStatic];


/**
 * Модель пользователя
 * @export
 * @interface DtoUserForResponse
 */
export interface DtoUserForResponse {
    /**
     * 
     * @type {string}
     * @memberof DtoUserForResponse
     */
    'fio'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUserForResponse
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUserForResponse
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUserForResponse
     */
    'public_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUserForResponse
     */
    'role_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUserForResponse
     */
    'role_name'?: string;
}
/**
 * DTO для обновления информации о пользователе
 * @export
 * @interface DtoUserUpdate
 */
export interface DtoUserUpdate {
    /**
     * 
     * @type {string}
     * @memberof DtoUserUpdate
     */
    'fio'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUserUpdate
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUserUpdate
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof DtoUserUpdate
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOut
 */
export interface GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOut {
    /**
     * 
     * @type {string}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOut
     */
    'cargo_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOut
     */
    'cargo_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOut
     */
    'cargo_type_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOut
     */
    'cargo_weight'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOut
     */
    'depart_loc'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOut
     */
    'dispatcher_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOut
     */
    'driver_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOut
     */
    'goal_loc'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOut
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOut
     */
    'is_urgent'?: boolean;
    /**
     * 
     * @type {GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOutStatus}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOut
     */
    'order_status_name'?: GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOutStatus;
    /**
     * 
     * @type {string}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOut
     */
    'photo_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOut
     */
    'time'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOutStatus = {
    ACCEPT: 'Принят',
    CANCEL: 'Отменен',
    COMPLETE: 'Выполнен',
    NEW: 'Новый',
    UNKNOWN: 'Неизвестно'
} as const;

export type GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOutStatus = typeof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOutStatus[keyof typeof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOutStatus];


/**
 * 
 * @export
 * @interface GithubComVeresusTlApiInternalClientsTlOrdersClientDtoPersonalCatalogResponse
 */
export interface GithubComVeresusTlApiInternalClientsTlOrdersClientDtoPersonalCatalogResponse {
    /**
     * 
     * @type {GithubComVeresusTlApiInternalClientsTlOrdersClientDtoPersonalCatalogSet}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoPersonalCatalogResponse
     */
    'completed'?: GithubComVeresusTlApiInternalClientsTlOrdersClientDtoPersonalCatalogSet;
    /**
     * 
     * @type {GithubComVeresusTlApiInternalClientsTlOrdersClientDtoPersonalCatalogSet}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoPersonalCatalogResponse
     */
    'in_work'?: GithubComVeresusTlApiInternalClientsTlOrdersClientDtoPersonalCatalogSet;
    /**
     * 
     * @type {GithubComVeresusTlApiInternalClientsTlOrdersClientDtoPersonalCatalogSet}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoPersonalCatalogResponse
     */
    'new'?: GithubComVeresusTlApiInternalClientsTlOrdersClientDtoPersonalCatalogSet;
}
/**
 * 
 * @export
 * @interface GithubComVeresusTlApiInternalClientsTlOrdersClientDtoPersonalCatalogSet
 */
export interface GithubComVeresusTlApiInternalClientsTlOrdersClientDtoPersonalCatalogSet {
    /**
     * 
     * @type {number}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoPersonalCatalogSet
     */
    'in_response'?: number;
    /**
     * 
     * @type {Array<GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOut>}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoPersonalCatalogSet
     */
    'orders'?: Array<GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOut>;
    /**
     * 
     * @type {number}
     * @memberof GithubComVeresusTlApiInternalClientsTlOrdersClientDtoPersonalCatalogSet
     */
    'total'?: number;
}
/**
 * DTO для передачи роли на фронт
 * @export
 * @interface GithubComVeresusTlApiInternalModelCheckResponse
 */
export interface GithubComVeresusTlApiInternalModelCheckResponse {
    /**
     * 
     * @type {string}
     * @memberof GithubComVeresusTlApiInternalModelCheckResponse
     */
    'name'?: string;
    /**
     * 
     * @type {DtoRoleStatic}
     * @memberof GithubComVeresusTlApiInternalModelCheckResponse
     */
    'role'?: DtoRoleStatic;
}


/**
 * DTO для передачи списка типов грузов и связей подразделений и зданий
 * @export
 * @interface GithubComVeresusTlApiInternalModelDropDownListInfoResponse
 */
export interface GithubComVeresusTlApiInternalModelDropDownListInfoResponse {
    /**
     * Мапа типов грузов
     * @type {{ [key: string]: string; }}
     * @memberof GithubComVeresusTlApiInternalModelDropDownListInfoResponse
     */
    'cargo_types'?: { [key: string]: string; };
    /**
     * Мапа связей подразделений и зданий
     * @type {{ [key: string]: string; }}
     * @memberof GithubComVeresusTlApiInternalModelDropDownListInfoResponse
     */
    'dep_builds'?: { [key: string]: string; };
}
/**
 * DTO для передачи информации о заявке
 * @export
 * @interface GithubComVeresusTlApiInternalModelOrderOut
 */
export interface GithubComVeresusTlApiInternalModelOrderOut {
    /**
     * 
     * @type {string}
     * @memberof GithubComVeresusTlApiInternalModelOrderOut
     */
    'cargo_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComVeresusTlApiInternalModelOrderOut
     */
    'cargo_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComVeresusTlApiInternalModelOrderOut
     */
    'cargo_type_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComVeresusTlApiInternalModelOrderOut
     */
    'cargo_weight'?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComVeresusTlApiInternalModelOrderOut
     */
    'depart_loc_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComVeresusTlApiInternalModelOrderOut
     */
    'dispatcher_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComVeresusTlApiInternalModelOrderOut
     */
    'driver_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComVeresusTlApiInternalModelOrderOut
     */
    'goal_loc_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComVeresusTlApiInternalModelOrderOut
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComVeresusTlApiInternalModelOrderOut
     */
    'is_urgent'?: boolean;
    /**
     * 
     * @type {GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOutStatus}
     * @memberof GithubComVeresusTlApiInternalModelOrderOut
     */
    'order_status_name'?: GithubComVeresusTlApiInternalClientsTlOrdersClientDtoOrderOutStatus;
    /**
     * 
     * @type {string}
     * @memberof GithubComVeresusTlApiInternalModelOrderOut
     */
    'photo_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComVeresusTlApiInternalModelOrderOut
     */
    'time'?: string;
}


/**
 * Ответ со списком заявок
 * @export
 * @interface GithubComVeresusTlApiInternalModelOrdersResponse
 */
export interface GithubComVeresusTlApiInternalModelOrdersResponse {
    /**
     * 
     * @type {number}
     * @memberof GithubComVeresusTlApiInternalModelOrdersResponse
     */
    'count'?: number;
    /**
     * 
     * @type {Array<GithubComVeresusTlApiInternalModelOrderOut>}
     * @memberof GithubComVeresusTlApiInternalModelOrdersResponse
     */
    'orders'?: Array<GithubComVeresusTlApiInternalModelOrderOut>;
}

/**
 * CheckApi - axios parameter creator
 * @export
 */
export const CheckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Проверка подключения к сервису
         * @summary Проверка подключения к сервису
         * @param {boolean} [isName] Если true — вернуть имя пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkGet: async (isName?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isName !== undefined) {
                localVarQueryParameter['is_name'] = isName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckApi - functional programming interface
 * @export
 */
export const CheckApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CheckApiAxiosParamCreator(configuration)
    return {
        /**
         * Проверка подключения к сервису
         * @summary Проверка подключения к сервису
         * @param {boolean} [isName] Если true — вернуть имя пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkGet(isName?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComVeresusTlApiInternalModelCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkGet(isName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckApi.checkGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CheckApi - factory interface
 * @export
 */
export const CheckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CheckApiFp(configuration)
    return {
        /**
         * Проверка подключения к сервису
         * @summary Проверка подключения к сервису
         * @param {boolean} [isName] Если true — вернуть имя пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkGet(isName?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<GithubComVeresusTlApiInternalModelCheckResponse> {
            return localVarFp.checkGet(isName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CheckApi - object-oriented interface
 * @export
 * @class CheckApi
 * @extends {BaseAPI}
 */
export class CheckApi extends BaseAPI {
    /**
     * Проверка подключения к сервису
     * @summary Проверка подключения к сервису
     * @param {boolean} [isName] Если true — вернуть имя пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckApi
     */
    public checkGet(isName?: boolean, options?: RawAxiosRequestConfig) {
        return CheckApiFp(this.configuration).checkGet(isName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IdentityApi - axios parameter creator
 * @export
 */
export const IdentityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает информацию о пользователе по его ID (int или UUID)
         * @summary Получить пользователя по ID
         * @param {string} id ID пользователя (число или UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identUsersIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('identUsersIdGet', 'id', id)
            const localVarPath = `/ident/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет информацию о пользователе по его ID (int или UUID)
         * @summary Обновить данные пользователя
         * @param {string} id ID пользователя (число или UUID)
         * @param {DtoUserUpdate} user Данные для обновления
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identUsersIdPatch: async (id: string, user: DtoUserUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('identUsersIdPatch', 'id', id)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('identUsersIdPatch', 'user', user)
            const localVarPath = `/ident/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Проверяет, существует ли логин в системе
         * @summary Проверка уникальности логина
         * @param {string} login Логин для проверки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicAuthCheckLoginLoginGet: async (login: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'login' is not null or undefined
            assertParamExists('publicAuthCheckLoginLoginGet', 'login', login)
            const localVarPath = `/public/auth/check-login/{login}`
                .replace(`{${"login"}}`, encodeURIComponent(String(login)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Входит в систему
         * @summary Входит в систему
         * @param {DtoLoginRequest} user Данные для входа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicAuthLoginPost: async (user: DtoLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('publicAuthLoginPost', 'user', user)
            const localVarPath = `/public/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Выходит из системы
         * @summary Выходит из системы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicAuthLogoutPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создает нового пользователя в системе
         * @summary Зарегистрировать нового пользователя
         * @param {DtoRegisterRequest} user Данные для регистрации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicAuthRegisterPost: async (user: DtoRegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('publicAuthRegisterPost', 'user', user)
            const localVarPath = `/public/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityApi - functional programming interface
 * @export
 */
export const IdentityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentityApiAxiosParamCreator(configuration)
    return {
        /**
         * Возвращает информацию о пользователе по его ID (int или UUID)
         * @summary Получить пользователя по ID
         * @param {string} id ID пользователя (число или UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identUsersIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoUserForResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identUsersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.identUsersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновляет информацию о пользователе по его ID (int или UUID)
         * @summary Обновить данные пользователя
         * @param {string} id ID пользователя (число или UUID)
         * @param {DtoUserUpdate} user Данные для обновления
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identUsersIdPatch(id: string, user: DtoUserUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identUsersIdPatch(id, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.identUsersIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Проверяет, существует ли логин в системе
         * @summary Проверка уникальности логина
         * @param {string} login Логин для проверки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicAuthCheckLoginLoginGet(login: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicAuthCheckLoginLoginGet(login, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.publicAuthCheckLoginLoginGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Входит в систему
         * @summary Входит в систему
         * @param {DtoLoginRequest} user Данные для входа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicAuthLoginPost(user: DtoLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicAuthLoginPost(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.publicAuthLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Выходит из системы
         * @summary Выходит из системы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicAuthLogoutPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicAuthLogoutPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.publicAuthLogoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Создает нового пользователя в системе
         * @summary Зарегистрировать нового пользователя
         * @param {DtoRegisterRequest} user Данные для регистрации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicAuthRegisterPost(user: DtoRegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicAuthRegisterPost(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.publicAuthRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IdentityApi - factory interface
 * @export
 */
export const IdentityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentityApiFp(configuration)
    return {
        /**
         * Возвращает информацию о пользователе по его ID (int или UUID)
         * @summary Получить пользователя по ID
         * @param {string} id ID пользователя (число или UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identUsersIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DtoUserForResponse> {
            return localVarFp.identUsersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновляет информацию о пользователе по его ID (int или UUID)
         * @summary Обновить данные пользователя
         * @param {string} id ID пользователя (число или UUID)
         * @param {DtoUserUpdate} user Данные для обновления
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identUsersIdPatch(id: string, user: DtoUserUpdate, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.identUsersIdPatch(id, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Проверяет, существует ли логин в системе
         * @summary Проверка уникальности логина
         * @param {string} login Логин для проверки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicAuthCheckLoginLoginGet(login: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.publicAuthCheckLoginLoginGet(login, options).then((request) => request(axios, basePath));
        },
        /**
         * Входит в систему
         * @summary Входит в систему
         * @param {DtoLoginRequest} user Данные для входа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicAuthLoginPost(user: DtoLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.publicAuthLoginPost(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Выходит из системы
         * @summary Выходит из системы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicAuthLogoutPost(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.publicAuthLogoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Создает нового пользователя в системе
         * @summary Зарегистрировать нового пользователя
         * @param {DtoRegisterRequest} user Данные для регистрации
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicAuthRegisterPost(user: DtoRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.publicAuthRegisterPost(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdentityApi - object-oriented interface
 * @export
 * @class IdentityApi
 * @extends {BaseAPI}
 */
export class IdentityApi extends BaseAPI {
    /**
     * Возвращает информацию о пользователе по его ID (int или UUID)
     * @summary Получить пользователя по ID
     * @param {string} id ID пользователя (число или UUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public identUsersIdGet(id: string, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).identUsersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновляет информацию о пользователе по его ID (int или UUID)
     * @summary Обновить данные пользователя
     * @param {string} id ID пользователя (число или UUID)
     * @param {DtoUserUpdate} user Данные для обновления
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public identUsersIdPatch(id: string, user: DtoUserUpdate, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).identUsersIdPatch(id, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Проверяет, существует ли логин в системе
     * @summary Проверка уникальности логина
     * @param {string} login Логин для проверки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public publicAuthCheckLoginLoginGet(login: string, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).publicAuthCheckLoginLoginGet(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Входит в систему
     * @summary Входит в систему
     * @param {DtoLoginRequest} user Данные для входа
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public publicAuthLoginPost(user: DtoLoginRequest, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).publicAuthLoginPost(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Выходит из системы
     * @summary Выходит из системы
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public publicAuthLogoutPost(options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).publicAuthLogoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создает нового пользователя в системе
     * @summary Зарегистрировать нового пользователя
     * @param {DtoRegisterRequest} user Данные для регистрации
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public publicAuthRegisterPost(user: DtoRegisterRequest, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).publicAuthRegisterPost(user, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает список всех актуальных заявок
         * @summary Получить все актуальные заявки
         * @param {boolean} [isPrivate] Приватные заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersActualGet: async (isPrivate?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders/actual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isPrivate !== undefined) {
                localVarQueryParameter['isPrivate'] = isPrivate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создает новую заявку в системе
         * @summary Создать новую заявку
         * @param {DtoOrderCreate} order Данные для создания заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersCreatePost: async (order: DtoOrderCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('ordersCreatePost', 'order', order)
            const localVarPath = `/orders/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(order, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Принимает заявку водителем
         * @summary Принять заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdAcceptPatch: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersIdAcceptPatch', 'id', id)
            const localVarPath = `/orders/{id}/accept`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отменяет заявку
         * @summary Отменить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdCancelPatch: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersIdCancelPatch', 'id', id)
            const localVarPath = `/orders/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Завершает заявку
         * @summary Завершить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdCompletePatch: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersIdCompletePatch', 'id', id)
            const localVarPath = `/orders/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о заявке по её ID
         * @summary Получить заявку по ID
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersIdGet', 'id', id)
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет существующую заявку
         * @summary Обновить заявку
         * @param {number} id ID заявки
         * @param {DtoOrderUpdate} order Данные для обновления заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdPatch: async (id: number, order: DtoOrderUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersIdPatch', 'id', id)
            // verify required parameter 'order' is not null or undefined
            assertParamExists('ordersIdPatch', 'order', order)
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(order, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отклоняет заявку водителем
         * @summary Отклонить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdRejectPatch: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersIdRejectPatch', 'id', id)
            const localVarPath = `/orders/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает сеты заказов (в работе, новые, завершенные)
         * @summary Личный каталог заказов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPersonalCatalogGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders/personal/catalog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет фотографию из системы
         * @summary Удалить фотографию
         * @param {string} id UUID фотографии
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPhotoIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersPhotoIdDelete', 'id', id)
            const localVarPath = `/orders/photo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отдает файл фотографии по UUID
         * @summary Получить файл фотографии
         * @param {string} id UUID фотографии
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPhotoIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersPhotoIdGet', 'id', id)
            const localVarPath = `/orders/photo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Загружает фотографию в систему
         * @summary Загрузить фотографию
         * @param {File} photo Фотография
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPhotoUploadPost: async (photo: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'photo' is not null or undefined
            assertParamExists('ordersPhotoUploadPost', 'photo', photo)
            const localVarPath = `/orders/photo/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (photo !== undefined) { 
                localVarFormParams.append('photo', photo as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает заявку с данными для обновления
         * @summary Получить заявку для обновления
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersUpdateIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersUpdateIdGet', 'id', id)
            const localVarPath = `/orders/update/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Возвращает список всех актуальных заявок
         * @summary Получить все актуальные заявки
         * @param {boolean} [isPrivate] Приватные заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersActualGet(isPrivate?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComVeresusTlApiInternalModelOrdersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersActualGet(isPrivate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersActualGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Создает новую заявку в системе
         * @summary Создать новую заявку
         * @param {DtoOrderCreate} order Данные для создания заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersCreatePost(order: DtoOrderCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersCreatePost(order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Принимает заявку водителем
         * @summary Принять заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersIdAcceptPatch(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersIdAcceptPatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersIdAcceptPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Отменяет заявку
         * @summary Отменить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersIdCancelPatch(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersIdCancelPatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersIdCancelPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Завершает заявку
         * @summary Завершить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersIdCompletePatch(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersIdCompletePatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersIdCompletePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает информацию о заявке по её ID
         * @summary Получить заявку по ID
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoOrder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновляет существующую заявку
         * @summary Обновить заявку
         * @param {number} id ID заявки
         * @param {DtoOrderUpdate} order Данные для обновления заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersIdPatch(id: number, order: DtoOrderUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersIdPatch(id, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Отклоняет заявку водителем
         * @summary Отклонить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersIdRejectPatch(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersIdRejectPatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersIdRejectPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает сеты заказов (в работе, новые, завершенные)
         * @summary Личный каталог заказов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersPersonalCatalogGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComVeresusTlApiInternalClientsTlOrdersClientDtoPersonalCatalogResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersPersonalCatalogGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersPersonalCatalogGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Удаляет фотографию из системы
         * @summary Удалить фотографию
         * @param {string} id UUID фотографии
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersPhotoIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersPhotoIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersPhotoIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Отдает файл фотографии по UUID
         * @summary Получить файл фотографии
         * @param {string} id UUID фотографии
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersPhotoIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersPhotoIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersPhotoIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Загружает фотографию в систему
         * @summary Загрузить фотографию
         * @param {File} photo Фотография
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersPhotoUploadPost(photo: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersPhotoUploadPost(photo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersPhotoUploadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает заявку с данными для обновления
         * @summary Получить заявку для обновления
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersUpdateIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DtoOrderForUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersUpdateIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersUpdateIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * Возвращает список всех актуальных заявок
         * @summary Получить все актуальные заявки
         * @param {boolean} [isPrivate] Приватные заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersActualGet(isPrivate?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<GithubComVeresusTlApiInternalModelOrdersResponse> {
            return localVarFp.ordersActualGet(isPrivate, options).then((request) => request(axios, basePath));
        },
        /**
         * Создает новую заявку в системе
         * @summary Создать новую заявку
         * @param {DtoOrderCreate} order Данные для создания заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersCreatePost(order: DtoOrderCreate, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ordersCreatePost(order, options).then((request) => request(axios, basePath));
        },
        /**
         * Принимает заявку водителем
         * @summary Принять заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdAcceptPatch(id: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ordersIdAcceptPatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Отменяет заявку
         * @summary Отменить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdCancelPatch(id: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ordersIdCancelPatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Завершает заявку
         * @summary Завершить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdCompletePatch(id: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ordersIdCompletePatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает информацию о заявке по её ID
         * @summary Получить заявку по ID
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<DtoOrder> {
            return localVarFp.ordersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновляет существующую заявку
         * @summary Обновить заявку
         * @param {number} id ID заявки
         * @param {DtoOrderUpdate} order Данные для обновления заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdPatch(id: number, order: DtoOrderUpdate, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ordersIdPatch(id, order, options).then((request) => request(axios, basePath));
        },
        /**
         * Отклоняет заявку водителем
         * @summary Отклонить заявку
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersIdRejectPatch(id: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ordersIdRejectPatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает сеты заказов (в работе, новые, завершенные)
         * @summary Личный каталог заказов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPersonalCatalogGet(options?: RawAxiosRequestConfig): AxiosPromise<GithubComVeresusTlApiInternalClientsTlOrdersClientDtoPersonalCatalogResponse> {
            return localVarFp.ordersPersonalCatalogGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Удаляет фотографию из системы
         * @summary Удалить фотографию
         * @param {string} id UUID фотографии
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPhotoIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ordersPhotoIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Отдает файл фотографии по UUID
         * @summary Получить файл фотографии
         * @param {string} id UUID фотографии
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPhotoIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.ordersPhotoIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Загружает фотографию в систему
         * @summary Загрузить фотографию
         * @param {File} photo Фотография
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersPhotoUploadPost(photo: File, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.ordersPhotoUploadPost(photo, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает заявку с данными для обновления
         * @summary Получить заявку для обновления
         * @param {number} id ID заявки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersUpdateIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<DtoOrderForUpdateResponse> {
            return localVarFp.ordersUpdateIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * Возвращает список всех актуальных заявок
     * @summary Получить все актуальные заявки
     * @param {boolean} [isPrivate] Приватные заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersActualGet(isPrivate?: boolean, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersActualGet(isPrivate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создает новую заявку в системе
     * @summary Создать новую заявку
     * @param {DtoOrderCreate} order Данные для создания заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersCreatePost(order: DtoOrderCreate, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersCreatePost(order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Принимает заявку водителем
     * @summary Принять заявку
     * @param {number} id ID заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersIdAcceptPatch(id: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersIdAcceptPatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Отменяет заявку
     * @summary Отменить заявку
     * @param {number} id ID заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersIdCancelPatch(id: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersIdCancelPatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Завершает заявку
     * @summary Завершить заявку
     * @param {number} id ID заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersIdCompletePatch(id: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersIdCompletePatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает информацию о заявке по её ID
     * @summary Получить заявку по ID
     * @param {number} id ID заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersIdGet(id: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновляет существующую заявку
     * @summary Обновить заявку
     * @param {number} id ID заявки
     * @param {DtoOrderUpdate} order Данные для обновления заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersIdPatch(id: number, order: DtoOrderUpdate, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersIdPatch(id, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Отклоняет заявку водителем
     * @summary Отклонить заявку
     * @param {number} id ID заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersIdRejectPatch(id: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersIdRejectPatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает сеты заказов (в работе, новые, завершенные)
     * @summary Личный каталог заказов
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersPersonalCatalogGet(options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersPersonalCatalogGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Удаляет фотографию из системы
     * @summary Удалить фотографию
     * @param {string} id UUID фотографии
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersPhotoIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersPhotoIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Отдает файл фотографии по UUID
     * @summary Получить файл фотографии
     * @param {string} id UUID фотографии
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersPhotoIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersPhotoIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Загружает фотографию в систему
     * @summary Загрузить фотографию
     * @param {File} photo Фотография
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersPhotoUploadPost(photo: File, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersPhotoUploadPost(photo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает заявку с данными для обновления
     * @summary Получить заявку для обновления
     * @param {number} id ID заявки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public ordersUpdateIdGet(id: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersUpdateIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReferencyApi - axios parameter creator
 * @export
 */
export const ReferencyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает список типов грузов и связей подразделений и зданий
         * @summary Возвращает список типов грузов и связей подразделений и зданий
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refDropdownListInfoGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ref/dropdown-list-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferencyApi - functional programming interface
 * @export
 */
export const ReferencyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferencyApiAxiosParamCreator(configuration)
    return {
        /**
         * Возвращает список типов грузов и связей подразделений и зданий
         * @summary Возвращает список типов грузов и связей подразделений и зданий
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refDropdownListInfoGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComVeresusTlApiInternalModelDropDownListInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refDropdownListInfoGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferencyApi.refDropdownListInfoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReferencyApi - factory interface
 * @export
 */
export const ReferencyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferencyApiFp(configuration)
    return {
        /**
         * Возвращает список типов грузов и связей подразделений и зданий
         * @summary Возвращает список типов грузов и связей подразделений и зданий
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refDropdownListInfoGet(options?: RawAxiosRequestConfig): AxiosPromise<GithubComVeresusTlApiInternalModelDropDownListInfoResponse> {
            return localVarFp.refDropdownListInfoGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferencyApi - object-oriented interface
 * @export
 * @class ReferencyApi
 * @extends {BaseAPI}
 */
export class ReferencyApi extends BaseAPI {
    /**
     * Возвращает список типов грузов и связей подразделений и зданий
     * @summary Возвращает список типов грузов и связей подразделений и зданий
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferencyApi
     */
    public refDropdownListInfoGet(options?: RawAxiosRequestConfig) {
        return ReferencyApiFp(this.configuration).refDropdownListInfoGet(options).then((request) => request(this.axios, this.basePath));
    }
}



